<?xml version="1.0" encoding="UTF-8"?>
<objects timestamp="Fri Oct 18 14:54:28 MDT 2013" framework.version="7.6.3.2013090513" fpmi.version="6.6.3.1354">
	<o cls="com.inductiveautomation.ignition.common.script.ScriptLibrary">
		<o-c m="setScripts" s="1;java.util.Map">
			<o cls="java.util.HashMap">
				<o-c m="put" s="2;O;O">
					<str>diagnostics.alertDisplays.pid</str>
					<str>def initialize(rootContainer):
	import app, system
	from java.util import Calendar
	
	print &quot;Initializing...&quot;

	rootContainer.initializationComplete = False
	modelType = &quot;pid&quot;
	cal = Calendar.getInstance()	

	eventLogId = rootContainer.eventLogId
	ruleId = rootContainer.ruleId
	ackd = rootContainer.ackd

	# Fetch the entire alert record and pass it to the alert display		
	pds, ds = app.alerts.common.fetchAlertDB(ruleId, &quot;&quot;)
	if ds.rowCount != 1:
		system.gui.warningBox(&quot;Alert details could not be found for this alert&quot;)
		return;

	# This callback can be used for an operator or an engineer, if this is an operator, then opening the
	# detail dialog is an implied ACK if the alert is not already acknowledged.
	print &quot;User roles: &quot;, system.security.getRoles()
	if &quot;RTA.Operators.GG&quot; in system.security.getRoles() and not(ackd):
		print &quot;Automatically acknowledging an unacknowledged alert for an operator&quot;
		app.alerts.alert.acknowledge(ruleId)	

	record = pds[0]
	rootContainer.internalName = modelType + str(ruleId)
	rootContainer.description = record[&quot;Description&quot;]
	rootContainer.explanation = record[&quot;Explanation&quot;]
	rootContainer.rationale = record[&quot;Rationale&quot;]
	rootContainer.ranking = record[&quot;Ranking&quot;]
	rootContainer.modelName = record[&quot;Name&quot;]
	rootContainer.manuallySuppressed = record[&quot;ManuallySuppressed&quot;]

	print &quot;Manually Suppresssed: &quot;, record[&quot;ManuallySuppressed&quot;]

	eventTime = record[&quot;EventTimeStamp&quot;]
	txt = app.common.dateTimeFormat.dateTimeFormat(eventTime)
	rootContainer.eventTime = eventTime
	rootContainer.eventTimeStamp = txt
		
	# Do all of the work of setting the start and end time of the charts so that the event is in the window
	app.alertDisplays.common.setChartTime(eventTime, rootContainer)
		
	ds = app.alertDisplays.common.fetchReferences(ruleId, -1)
	rootContainer.references = ds

	tagResults = app.pid.fetch.tags(ruleId)
	tagRecord = tagResults[0]
	
	rootContainer.pvTagName = tagRecord[&quot;PVTagName&quot;]
	rootContainer.pvTagPath = app.tags.get.historyTagPath(tagRecord[&quot;PVTagName&quot;])
	
	print &quot;PV tag path: &quot;, app.tags.get.historyTagPath(tagRecord[&quot;PVTagName&quot;])

	rootContainer.opTagName = tagRecord[&quot;OPTagName&quot;]
	rootContainer.opTagPath = app.tags.get.historyTagPath(tagRecord[&quot;OPTagName&quot;])
	
	rootContainer.spTagName = tagRecord[&quot;SPTagName&quot;]
	rootContainer.spTagPath = app.tags.get.historyTagPath(tagRecord[&quot;SPTagName&quot;])

	app.alertDisplays.common.setRankingButtonState(rootContainer, record[&quot;Ranking&quot;])
	
	# Update the related tag charts
	pds = app.alertDisplays.relatedTags.fetch(ruleId)
	app.alertDisplays.relatedTags.clear(rootContainer)
	app.alertDisplays.relatedTags.configure(rootContainer, pds)
	app.alertDisplays.relatedTags.updateAllCharts(rootContainer)
	
	# Update the main charts
	app.alertDisplays.pid.updatePVSP(rootContainer)
	app.alertDisplays.pid.updateOP(rootContainer)
	
	rootContainer.initializationComplete = True

	print &quot;Initialization is complete!&quot;


# The only reason that I am updating these here, in a script rather than just binding directly to the
# tag history is because I couldn&apos;t figure out a way to get the short tag name into the legend.	
def updatePVSP(rootContainer):
	import app, system
	
	print &quot;In pid.updatePVSP()&quot;
	chart = rootContainer.getComponent(&quot;PV SP Chart&quot;)
	dateWidget = rootContainer.getComponent(&quot;Date Range&quot;)
		
	# The documentation is not right here.  There is going to be one extra column in the ds than there are 
	# tags because the first column is timestamp.
	names = [&quot;tstamp&quot;, rootContainer.pvTagName, rootContainer.spTagName] 
	tagPaths = [rootContainer.pvTagPath, rootContainer.spTagPath]
	ds = system.tag.queryTagHistory(paths = tagPaths, startDate = dateWidget.startDate, endDate = dateWidget.endDate, columnNames = names)
	chart.ds = ds

	
def updateOP(rootContainer):
	import app, system
	
	print &quot;In pid.updateOP()&quot;
	
	chart = rootContainer.getComponent(&quot;OP Chart&quot;)
	dateWidget = rootContainer.getComponent(&quot;Date Range&quot;)
		
	# The documentation is not right here.  There is going to be one extra column in the ds than there are 
	# tags because the first column is timestamp.
	names = [&quot;tstamp&quot;, rootContainer.opTagName] 
	tagPaths = [rootContainer.opTagPath]
	ds = system.tag.queryTagHistory(paths = tagPaths, startDate = dateWidget.startDate, endDate = dateWidget.endDate, columnNames = names)
	chart.ds = ds</str>
				</o-c>
				<o-c m="put" s="2;O;O">
					<str>diagnostics.alertDisplays.commentBrowser</str>
					<str>def update(table):
	import app, system
	
	ds = table.rawData
	pds = system.dataset.toPyDataSet(ds)
	data = []
	for record in pds:
		userName = record[&quot;UserName&quot;]
		timestamp = record[&quot;CommentTimestamp&quot;]
		comment = record[&quot;Comment&quot;]
		eventLogId = record[&quot;EventLogID&quot;]
		ruleId = record[&quot;RuleID&quot;]
		
		timestampText = app.common.dateTimeFormat.dateTimeFormat(timestamp)
		
		userTime = &apos;&lt;HTML&gt;&lt;b&gt;&apos; + userName + &apos;&lt;/b&gt;&lt;br&gt;&apos; + timestampText
		if eventLogId == None or eventLogId &lt; 1:
			type = 0
		else:
			type = 1
			
		data.append([userTime, comment, type, eventLogId, ruleId])
		
	headers = [&quot;User&quot;, &quot;Comment&quot;, &quot;Type&quot;, &quot;Event&quot;, &quot;Rule&quot;]
	ds = system.dataset.toDataSet(headers, data)
	table.data = ds
	print &quot;Done&quot;

# This is called when the user pushes the button and we want to show the edit fields and make the table smaller.
def showField(rootContainer):
	import system
	print &quot;In showField&quot;
	rootContainer.getComponent(&quot;Button Container&quot;).visible = False
	rootContainer.getComponent(&quot;Comment Container&quot;).visible = True
	
	# position the table below the comment coontainer (X, Y, width, Height)
	table = rootContainer.getComponent(&quot;Table&quot;)
	system.gui.reshapeComponent(table, table.x, table.y + 48, table.width, table.height - 48)


def addComment(rootContainer):
	import app, system
	print &quot;In addCommentCallback&quot;

	comment = rootContainer.getComponent(&quot;Comment Container&quot;).getComponent(&quot;Comment&quot;).text
	userId = rootContainer.getComponent(&quot;Comment Container&quot;).getComponent(&quot;User&quot;).selectedValue
	username = rootContainer.getComponent(&quot;Comment Container&quot;).getComponent(&quot;User&quot;).selectedStringValue
	print &quot;Comment: %s&quot; % (comment)
	print &quot;User id: %i&quot; % (userId)
	print &quot;User Name: %s&quot; % (username)

	if comment == &quot;&quot;:
		system.gui.messageBox(&quot;Please enter a comment!&quot;)
		return

	if userId &lt; 0:
		system.gui.messageBox(&quot;Please select a user!&quot;)
		return

	ruleId = rootContainer.modelId
	eventLogId = rootContainer.eventLogId

	if eventLogId &gt; 0:
		SQL = &quot;insert into CommentLog (EventLogId, RuleId, CommentAuthorId, CommentTimestamp, Comment)&quot;
		SQL = SQL + &quot; values (?,?,?,GETDATE(),?)&quot;
		rows = system.db.runPrepUpdate(query = SQL, args = [eventLogId, ruleId, userId, comment], getKey = 0)
	else:
		SQL = &quot;insert into CommentLog (RuleId, CommentAuthorId, CommentTimestamp, Comment)&quot;
		SQL = SQL + &quot; values (?,?,GETDATE(),?)&quot;
		rows = system.db.runPrepUpdate(query = SQL, args = [ruleId, userId, comment], getKey = 0)	

	print &quot;Inserted %i comments&quot; % (rows)

	# Refresh the comment table to show the comment we just added
	system.db.refresh(rootContainer.getComponent(&quot;Table&quot;), &quot;rawData&quot;)
	
	app.alertDisplays.commentBrowser.reset(rootContainer)	

	if eventLogId &gt; 0:
		record = app.database.fetch.event(eventLogId)
		app.alerts.email.newComment(ruleId, record[&apos;Name&apos;], comment, username, record[&apos;Description&apos;], record[&apos;Rationale&apos;], record[&apos;EventTimeStamp&apos;])

		# Fetch the comment counts and get the ranking so that we can format the response 3 line text string

		pds, ds = app.alerts.common.fetchAlertDB(ruleId, &quot;&quot;)
		if ds.rowCount != 1 or pds[0][&quot;Ranking&quot;] == None:
			ranking = &quot;&quot;
		else:
			record = pds[0]
			ranking = record[&quot;Ranking&quot;]
		
		numOldComments, numNewComments = app.alerts.alert.fetchCommentCounts(ruleId, eventLogId)
		response = app.alerts.alert.formatResponse(numOldComments, numNewComments, ranking)
	
		SQL = &quot;update Events set Response = ? where RuleId = ?&quot;
		system.db.runPrepUpdate( SQL, [ response, ruleId ] )


def cancel(rootContainer):
	import app
	print &quot;In cancel&quot;
	app.alertDisplays.commentBrowser.reset(rootContainer)

	
def reset(rootContainer):
	import system

	rootContainer.getComponent(&quot;Button Container&quot;).visible = True
	rootContainer.getComponent(&quot;Comment Container&quot;).visible = False

	table = rootContainer.getComponent(&quot;Table&quot;)
	system.gui.reshapeComponent(rootContainer.getComponent(&quot;Table&quot;), table.x, table.getPropertyValue(&quot;yAnchor&quot;), table.width, table.getPropertyValue(&quot;heightAnchor&quot;))

	rootContainer.getComponent(&quot;Comment Container&quot;).getComponent(&quot;Comment&quot;).text = &quot;&quot;
	rootContainer.getComponent(&quot;Comment Container&quot;).getComponent(&quot;User&quot;).selectedValue = -1</str>
				</o-c>
				<o-c m="put" s="2;O;O">
					<str>diagnostics.alertDisplays.test</str>
					<str>def test(event):
	import app
	print &quot;In test&quot;
	
	app.alertDisplays.relatedTags.configure(event.source.parent)
	</str>
				</o-c>
				<o-c m="put" s="2;O;O">
					<str>diagnostics.editHistory.update</str>
					<str>def update(rootContainer):
	import system
	
	table = rootContainer.getComponent(&quot;Table&quot;)
	nameFilter = rootContainer.getComponent(&quot;Name Filter&quot;).text
	idFilter = rootContainer.getComponent(&quot;Id Filter&quot;).text
	dateRange = rootContainer.getComponent(&quot;Date Range&quot;)
	
	# This will make character by character based filtering work better because 
	# if they just start typing characters it means that the name begins with those characters
	if nameFilter.find(&quot;%&quot;) &lt; 0:
		nameFilter = nameFilter + &quot;%&quot;

	if idFilter.find(&quot;%&quot;) &lt; 0:
		idFilter = idFilter + &quot;%&quot;

	print &quot;Name Filter: &quot;, nameFilter
	
	SQL = &quot;SELECT EditId, EditTimeStamp, RuleModelType, ObjectId, Name, EditAction, UserName, ChangeReason &quot;
	SQL = SQL + &quot; FROM EditHistoryView &quot;
	SQL = SQL + &quot; WHERE name like &apos;%s&apos; &quot; % (nameFilter)	
	SQL = SQL + &quot; and ObjectId like &apos;%s&apos; &quot; % (idFilter)
	SQL = SQL + &quot; and EditTimeStamp &gt; ? &quot;
	SQL = SQL + &quot; and EditTimeStamp &lt; ? &quot;
	SQL = SQL + &quot; order by EditTimeStamp DESC &quot;

	pds = system.db.runPrepQuery(SQL, args = [dateRange.startDate, dateRange.endDate])
	print pds
	
	table.data = pds</str>
				</o-c>
				<o-c m="put" s="2;O;O">
					<str>diagnostics.alerts.email</str>
					<str>def newAlert(modelId, modelName, description, rationale, eventTime):
	import system, app

	print &quot;Sending an e-mail for a new alert for model %i&quot; % (modelId)

	# Fetch the E-Mail addresses that are subscribed to the destinations

	SQL = &quot;select EMailAddress &quot;
	SQL = SQL + &quot;from UserEmail UE, RuleEmail RE, RuleModel RM &quot;
	SQL = SQL + &quot;where UE.EMailID = RE.EMailID &quot;
	SQL = SQL + &quot;and RE.RuleID = RM.RuleModelID &quot;
	SQL = SQL + &quot;and RM.RuleModelID = ?&quot;

	pds = system.db.runPrepQuery(SQL, [modelId])
	
	# If there are no E-Mails configured for this model, then we are done
	if len(pds) == 0:
		return

	emails = []	
	addresses = &quot;&quot;
	for row in pds:
		emails.append( str(row[0]) )	
		if addresses == &quot;&quot;:
			addresses = row[0]
		else:
			addresses = addresses + &quot;, &quot; + row[0]

	# TODO Add a check to see if the email address list is empty
	
	print &quot;E-Mails: &quot;, emails
	print &quot;Addresses: &quot;, addresses

	destinations = app.alerts.email.fetchDestinations(modelId)
	subject = &quot;RTA: %s (ID: %i) (%s)&quot; % (modelName, modelId, destinations)
	eventTimestamp = app.common.dateTimeFormat.dateTimeFormat(eventTime)

	body = &quot;Event Time: %s\n------------------------------------\nModel Name: %s\nMessage Text: %s\nRationale: %s\n&quot; % (eventTimestamp, modelName, description, rationale)

	app.alerts.email._send(emails, subject, body)


# Comments that are entered for an alert get e-mailed to every e-mail that is subscribed to the destination
def newComment(modelId, modelName, comment, author, description, rationale, eventTime):
	import system, app

	print &quot;Sending an e-mail for a new comment for model %i&quot; % (modelId)
	
	# Fetch the E-Mail addresses that are subscribed to the destinations

	SQL = &quot;select distinct EMailAddress &quot;
	SQL = SQL + &quot;from UserEmail UE, UserCommentEmail UCE, RuleDestination RD, RuleModel RM &quot;
	SQL = SQL + &quot;where UE.EMailID = UCE.EMailID &quot;
	SQL = SQL + &quot; and UCE.DestinationID = RD.DestinationID &quot;
	SQL = SQL + &quot; and RD.RuleID = RM.RuleModelID &quot;
	SQL = SQL + &quot;and RM.RuleModelID = ?&quot;

	pds = system.db.runPrepQuery(SQL, [modelId])

	# If there are no E-Mails configured for this destination, then we are done
	if len(pds) == 0:
		return

	emails = []	
	addresses = &quot;&quot;
	for row in pds:
		emails.append( str(row[0]) )	
		if addresses == &quot;&quot;:
			addresses = row[0]
		else:
			addresses = addresses + &quot;, &quot; + row[0]

	print &quot;E-Mails: &quot;, emails
	print &quot;Addresses: &quot;, addresses
	
	modelName, explanation, description = app.database.fetch.modelInfo(modelId)
	destinations = app.alerts.email.fetchDestinations(modelId)

	eventTimestamp = app.common.dateTimeFormat.dateTimeFormat(eventTime)
	uline = &quot;----------------------------------------------------&quot;
	contents = &quot;Event Time: %s\n%s\nModel Name: %s\nMessage Test: %s\nRationale: %s\n&quot; % (eventTimestamp, uline, modelName, description, rationale)
	
	subject = &quot;New RTA Comment: %s (ID: %i) (%s)&quot; % (modelName, modelId, destinations)
	body = &quot;RESPONSE:\n%s (by %s) \n\n%s \n\n%s&quot; % (comment, author, contents, addresses)

	app.alerts.email._send(emails, subject, body)


# Call the Ignition email API	
def _send(emails, subject, body):
	import system
	import system.ils.aed.properties as properties
	debug = False

	smtp = properties.getSMTPAddress()
	fromAddress = properties.getFromAddress()
#	username = properties.getUsername()
#	password = properties.getPassword()

	if debug:
		print &quot;&quot;
		print &quot;Sending Email:&quot;
		print &quot;  SMTP:     &quot;, smtp
		print &quot;  From:     &quot;, fromAddress
		print &quot;  To:       &quot;, emails
#		print &quot;  Username: &quot;, username
#		print &quot;  Password: &quot;, password
		print &quot;  Subject:  &quot;, subject
		print &quot;Body:&quot;
		print body	
		print &quot;&quot;

	def sender(smtp=smtp, fromAddress=fromAddress, subject=subject, body=body, emails=emails):
#	def sender(smtp=smtp, fromAddress=fromAddress, subject=subject, body=body, emails=emails, username=username, password=password):
#		print &quot;In sender...&quot;
#		print &quot;**Body**: &quot;, body
#		print &quot;**To**: &quot;, emails
#		system.net.sendEmail(smtp=smtp, fromAddr=fromAddress, subject=subject, body=body, to=emails, username=username, password=password)
		system.net.sendEmail(smtp=smtp, fromAddr=fromAddress, subject=subject, body=body, to=emails)

#		print &quot;E-Mail has been sent!&quot;

	enabled = system.tag.read(&apos;[AED]Global Settings/Email Enabled&apos;).value
#	print &quot;Email system is enabled: &quot;, enabled

	if enabled:
#		print &quot;Submitting...&quot;
		system.util.invokeAsynchronous(sender)
#		system.net.sendEmail(smtp=smtp, fromAddr=fromAddress, subject=subject, body=body, to=emails, username=username, password=password)
#		print &quot;Submitted!&quot;
	else:
		print &quot;The e-mail was not sent because e-mail is disabled!&quot;

# Fetch the destinations this rule posts to
def fetchDestinations(ruleId):
	import app, system

	SQL = &quot;select distinct Name &quot;
	SQL = SQL + &quot;from Destination D, RuleDestination RD &quot;
	SQL = SQL + &quot;where D.DestinationId = RD.DestinationId &quot;
	SQL = SQL + &quot;and RD.RuleId = ?&quot;
	
	pds = system.db.runPrepQuery(SQL, [ruleId])

	destinations = &quot;&quot;
	for row in pds:
		if destinations == &quot;&quot;:
			destinations = row[0]
		else:
			destinations = destinations + &quot;, &quot; + row[0]
	
	return destinations</str>
				</o-c>
				<o-c m="put" s="2;O;O">
					<str>diagnostics.component</str>
					<str></str>
				</o-c>
				<o-c m="put" s="2;O;O">
					<str>diagnostics.alerts.alert</str>
					<str>def checkUnsuppressionSchedule():
	import system, app
	from java.util import Date
	from java.util import Calendar
		
	# Determine if exactly one hour ago was the end of shift
	now = Date()
	cal = Calendar.getInstance()
	cal.setTime(now)
	cal.add(Calendar.HOUR, -1)
	hour = cal.get(Calendar.HOUR_OF_DAY)
	minute = cal.get(Calendar.MINUTE)
	
	SQL = &quot;select count(*) from UnsuppressSchedule where TargetHour = %i and TargetMinute = %i&quot; % (hour, minute)
	print SQL
	cnt = system.db.runScalarQuery(SQL)
	if cnt &gt; 0:
		print &quot;It is time to delete the stale suppressions!&quot;
		app.alerts.alert.clearOldManualSuppression()


# Delete all of the manual suppressions whose time is more than an hour old.  This runs exactly one hour after
# a shift change.  The idea is that the new operator has exactly one hour to review and confirm the manual 
# suppressions applied by the previous operator. 
def clearOldManualSuppression():
	import system
	
	SQL = &quot;delete from Suppressors where SuppressionType = &apos;Manual&apos; and TimeStamp  &lt; dateadd(hh, -1, getdate())&quot;
	rows = system.db.runUpdateQuery(SQL)
	
	print &quot;Deleted %i stale manual suppressors&quot; % (rows)


def set(ruleId, type, name, description, rationale, explanation, numSuppressors, manualCounter, automaticCounter, internalCounter, suppressionDescription, status, database, result, debug):
	from datetime import datetime
	import app, system, string
	
	status = string.capitalize(status)
	
	if debug:
		print &quot;In app.alerts.alert.set() with rule id: %i (%s) &quot; % (ruleId, status)
		print &quot;Description: %s&quot; % (description)
		print &quot;Rationale: %s&quot; % (rationale)
		print &quot;Explanation: %s&quot; % (explanation)
		print &quot;Number of suppressors: %i (Manual: %i, Automatic %i, Internal: %i)&quot; % (numSuppressors,  manualCounter, automaticCounter, internalCounter)

	tx = system.db.beginTransaction(timeout=5000, database = database)

	severity = 1
	acknowledged = False
	operatingEnvelopeEvent = 0

	destinations = app.alerts.alert.fetchDestinations(ruleId)

	if manualCounter &gt; 0:
		manuallySuppressed = True
	else:
		manuallySuppressed = False
					
	# The first transaction is to insert a record into the EventLog and return the unique EventLogId
	# The eventTimestamp column was modified to have a default value of getDate() so I don&apos;t need to pass it here!
	eventLogId = app.alerts.alert.insertAlertIntoEventLog(ruleId, status, description, explanation, tx, debug)

	if debug:
		print &quot;The id for the new event is: &quot;, eventLogId
	
	# Update the RuleStatus table (which drives the Model Browser)
	app.alerts.alert.updateRuleStatus(ruleId, eventLogId, status, tx, debug)

	# Determine if there is already a record in the Events table for this rule/model.  
	SQL = &quot;SELECT count(*) FROM events where RuleId = &quot; + str(ruleId)
	numRows = system.db.runScalarQuery(SQL, tx = tx)

	if debug:
		print &quot;There are &quot;, numRows, &quot; in events with id &lt;&quot;, ruleId, &quot;&gt;&quot;

	# Calculate the Shown flag
	
	if string.lower(status) == &quot;suppressed&quot;:
		shown = False
	else:
		shown = True
	
	# Insert a new record into the Events table, or update an existing one, which drives the Event browsers
	if (numRows == 0):
		numOldComments, numNewComments = app.alerts.alert.fetchCommentCounts(ruleId, eventLogId)
		response = app.alerts.alert.formatResponse(numOldComments, numNewComments, &quot;&quot;)
		
		SQL = &quot;insert into Events (EventLogId, RuleId, Name, Description, Rationale, Explanation, Severity, Type, Destination, &quot;
		SQL = SQL + &quot;Acknowledged, OperatingEnvelopeEvent, ManuallySuppressed, &quot;
		SQL = SQL + &quot;SuppressedCntr, SuppressionType, Response, EventTimeStamp, Shown) values (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?, GETDATE(), ?)&quot;

		rows = system.db.runPrepUpdate(query = SQL, args = [eventLogId, ruleId, name, description, rationale, explanation, 
			severity, type, destinations, acknowledged, operatingEnvelopeEvent, manuallySuppressed, 
			numSuppressors, suppressionDescription, response, shown], tx = tx, getKey = 0)

		app.alerts.email.newAlert(ruleId, name, description, rationale, datetime.now())
		
		if debug:
			print &quot;Inserted &quot;, rows, &quot; rows into Events!&quot;
	else:
		SQL = &quot;update Events set EventLogId = ?, EventTimeStamp = GETDATE(), ClearTimeStamp = NULL, severity = ?, description = ?, explanation = ?, &quot;
		SQL = SQL + &quot;ManuallySuppressed = ?, SuppressedCntr = ?, SuppressionType = ? where RuleId = ?&quot;
		rows = system.db.runPrepUpdate(query = SQL, args = [eventLogId, severity, description, explanation, 
			manuallySuppressed, numSuppressors, suppressionDescription, ruleId], tx = tx, getKey = 0)
		
		if debug:
			print &quot;SQL:&quot; + SQL +&quot;, Updated &quot;, rows, &quot; rows!&quot;
	  
	system.db.commitTransaction(tx)
	system.db.closeTransaction(tx)


def clear(ruleId, database, status, debug):
	import app, system

	if debug:
		print &quot;In app.alerts.alert.clear with rule or model id: &quot;, ruleId
	
	tx = system.db.beginTransaction(timeout=5000, database = database)
			
	# The first transaction is to insert a record into the EventLog and return the unique EventLogId
	# The eventTimestamp column was modified to have a default value of getDate() so I don&apos;t need to pass it here!
	SQL = &quot;insert into EventLog (RuleId, Status, EventTimeStamp) values (?, &apos;False&apos;, GETDATE())&quot;
	eventLogId = system.db.runPrepUpdate(query = SQL, args = [ruleId], tx = tx, getKey = 1)

	if debug:
		print &quot;   The id for the cleared event is: &quot;, eventLogId
	
	# Update the RuleStatus table (which drives the Model Browser)
	app.alerts.alert.updateRuleStatus(ruleId, eventLogId, status, tx, debug)

	# Determine if there is a record in the Events table for this rule/model, if there is then either update it
	# or delete it based on its state
	pds, ds = app.alerts.common.fetchAlertDB(ruleId, tx)

	if len(pds) != 0:
		if debug:
			print &quot;   found an event&quot;
	
		acknowledged = pds[0][&apos;Acknowledged&apos;]
		if debug:
			print &quot;   Acknowledged: &quot;, acknowledged

		# if the alert is cleared AND acknowldeged, then just delete it, otherwise need to update its clear timestamp	
		if acknowledged:
			SQL = &quot;delete from Events where RuleId = ?&quot;
		else:	
			SQL = &quot;update Events set clearTimeStamp = GETDATE(), severity = 0 where RuleId = ?&quot;

		rows = system.db.runPrepUpdate(SQL, [ruleId], &quot;&quot;, tx, 0)
		
	system.db.commitTransaction(tx)
	system.db.closeTransaction(tx)


def disable(ruleId, database, debug):
	import app, system
	
	if debug:
		print &quot;In app.alerts.alert.disable with &quot;, ruleId
	
	tx = system.db.beginTransaction(timeout=5000, database = database)
	eventLogId = app.alerts.alert.insertEventLog(ruleId, &quot;Disabled&quot;, tx)
	app.alerts.alert.updateRuleStatus(ruleId, eventLogId, &quot;Disabled&quot;, tx)
	system.db.commitTransaction(tx)
	system.db.closeTransaction(tx)


def manualSuppress(ruleId):
	import app, system
	print &quot;In manualSuppress&quot;, ruleId
	
	# The current user is the suppressor, we&apos;ll use the id, the name is meaningless since they use generic console ids
	username, userId, fullName = app.common.userInfo.getUsername()

	# This is normally run from a client, so the default database would work, but it can also be called from the gateway as part
	# of test automation.
	dbName = app.startup.gateway.getDBName()
	tx = system.db.beginTransaction(timeout=5000, database=dbName)

	SQL = &quot;insert into Suppressors (SuppressorId, TargetId, SuppressionType, TimeStamp) values (?, ?, &apos;Manual&apos;, GETDATE())&quot;
	rows = system.db.runPrepUpdate(query = SQL, args = [userId, ruleId], tx = tx, getKey = 0)
	system.db.commitTransaction(tx)
		
	numSuppressors, manualCounter, automaticCounter, internalCounter, description = app.engine.suppression.querySuppressors(ruleId, False)
	SQL = &quot;update Events set ManuallySuppressed = 1, SuppressionType = &apos;&quot; + description + &quot;&apos; where RuleId = &quot; + str(ruleId)
	rows = system.db.runUpdateQuery(SQL, &quot;&quot;, tx, 0)
	system.db.commitTransaction(tx)
	
	app.alerts.common.updateRuleStatus(ruleId, True, tx)
	system.db.commitTransaction(tx)
	
	system.db.closeTransaction(tx)


# Confirm the manual suppression of an event by updating the 
# timestamp of the suppression record.  The purpose is to renew the suppression so that it doesn&apos;t automatically
# get unsuppressed at one hour past the shift change.
def confirmManualSuppression(ruleId):
	import app, system
	print &quot;In confirmManualSuppress&quot;, ruleId

	SQL = &quot;update Suppressors set TimeStamp = GETDATE() where targetId = %i and SuppressionType = &apos;Manual&apos;&quot; % (ruleId)
	rows = system.db.runUpdateQuery(SQL)		


def manualUnsuppress(ruleId):
	import app, system
	print &quot;In manual**Un**Suppress &quot;, ruleId
	
	tx = system.db.beginTransaction(timeout=5000)

	# Update the Events table which will drive the Event Browsers	
	SQL = &quot;update Events set ManuallySuppressed = 0, SuppressedBy = &apos;DD&apos; where RuleId = &quot; + str(ruleId)
	rows = system.db.runUpdateQuery(SQL, &quot;&quot;, tx, 0)
	
	# Update the Suppressors table which need to be updated before the next execution cycle
	SQL = &quot;delete from Suppressors where TargetId = &quot; + str(ruleId) + &quot; and SuppressionType = &apos;Manual&apos;&quot;
	rows = system.db.runUpdateQuery(SQL, &quot;&quot;, tx, 0)
	system.db.commitTransaction(tx)
	
	app.alerts.common.updateRuleStatus(ruleId, True, tx)
	system.db.commitTransaction(tx)
	
	system.db.closeTransaction(tx)


# This acknowledges the alert for the specified model.  It updates the record in the EventLog.
# If the alert has cleared, then it deletes the record from events because it has cleared and has been acknowledged.
# If it hasn&apos;t clear, then it updates the  
def acknowledge(ruleId):
	import app, system
	
	print &quot;In acknowledge(), acknowledging: &quot;, ruleId

	# This is normally run from a client, so the default database would work, but it can also be called from the gateway as part
	# of test automation.
	dbName = app.startup.gateway.getDBName()
	tx = system.db.beginTransaction(timeout=5000, database=dbName)

	username, userId, fullname = app.common.userInfo.getUsername()
	
	# Get alert info from the Events table
	pds, ds = app.alerts.common.fetchAlertDB(ruleId, tx) 

	# If everything goes right, there should be no way that we don&apos;t find the alert, but check just to be safe
	if len(pds) == 0:
		print &quot;No alerts found for model &quot;, ruleId
		system.db.commitTransaction(tx)
		system.db.closeTransaction(tx)
		return

	eventLogId = pds[0][&apos;EventLogID&apos;]
	clearTimeStamp = pds[0][&apos;ClearTimeStamp&apos;]
	print &quot;Clear Time: &quot;, clearTimeStamp
	
	# Update the EventLog
	SQL = &quot;update EventLog set acknowledgedBy = ?, AckTimeStamp = GETDATE() where EventLogId = ?&quot;
	rows = system.db.runPrepUpdate(SQL, [userId, eventLogId], &quot;&quot;, tx, 0)
	
	# Update the Events table
	# if the alert is cleared AND acknowldeged, then just delete it, otherwise need to update its clear timestamp
	if clearTimeStamp != None:
		print &quot;Deleting the event because it is acknowldeged and cleared!&quot;
		SQL = &quot;delete from Events where RuleId = ?&quot;
		rows = system.db.runPrepUpdate(SQL, [ruleId], &quot;&quot;, tx, 0)
	else:
		print &quot;Acknowleding an existing alert!&quot;
		SQL = &quot;update Events set acknowledged = 1, Severity = 2, AckTimeStamp = GETDATE(), AckUsername = ? where RuleId = ?&quot;
		rows = system.db.runPrepUpdate(SQL, [username, ruleId], &quot;&quot;, tx, 0)
		
	system.db.commitTransaction(tx)
	system.db.closeTransaction(tx)


# This ranks the alert for the specified model.  It updates the record in the EventLog.
# Ranking an alert does an implied acknowledgement.  If the alert has cleared, then it deletes the record from events table,
# which removes it from the browser because it has cleared and has been acknowledged.  
def rank(eventLogId, ruleId, ranking):
	import app, system
		
	print &quot;In rank(), eventLogId: %i, modelId: %i, ranking: %s...&quot; % (eventLogId, ruleId, ranking)

	tx = system.db.beginTransaction(timeout=5000)	
	username, userId, fullname = app.common.userInfo.getUsername()

	# Get alert info from the Events table		
	pds, ds = app.alerts.common.fetchAlertDB(ruleId, tx) 

	print pds
	print ds
	
	# If there isn&apos;t a record in the events table, then it has cleared and acknowledged!
	if	len(pds) == 0:
		eventExists = False
		acknowledged = True	
	else:
		eventExists = True
		acknowledged = pds[0][&apos;Acknowledged&apos;]

	print &quot;Event exists: &quot;, eventExists

	# Update the EventLog (technically, the alert could have already been ACK&apos;d, I could check it before I update)
	if acknowledged:
		print &quot;The alert has already been acknowledged, saving the ranking...&quot;
		SQL = &quot;update EventLog set Ranking = ? where EventLogId = ?&quot;
		rows = system.db.runPrepUpdate(SQL, [ranking, eventLogId], &quot;&quot;, tx, 0)
	else:
		print &quot;Ranking and acknowledging the alert...&quot;
		SQL = &quot;update EventLog set AcknowledgedBy = ?, Ranking = ?, AckTimeStamp = GETDATE() where EventLogId = ?&quot;
		rows = system.db.runPrepUpdate(SQL, [userId, ranking, eventLogId], &quot;&quot;, tx, 0)

	# Update the Events table
	if eventExists:
		print &quot;Now updating the Events table...&quot;
		clearTimeStamp = pds[0][&apos;ClearTimeStamp&apos;]
		
		# if the alert is cleared AND acknowldeged, then just delete it, otherwise need to update its clear timestamp
		if clearTimeStamp != None:
			print &quot;Deleting the event because it is acknowldeged and cleared!&quot;
			SQL = &quot;delete from Events where RuleId = ?&quot;
			rows = system.db.runPrepUpdate(SQL, [ruleId], &quot;&quot;, tx, 0)
		else:
			# Fetch the comment counts so that we can format the response 3 line text string
			numOldComments, numNewComments = app.alerts.alert.fetchCommentCounts(ruleId, eventLogId)
			response = app.alerts.alert.formatResponse(numOldComments, numNewComments, ranking)
			print &quot;The reponse is: &quot; + response

			if not(acknowledged):
				print &quot;Ranking an alert that was not acknowledged!&quot;
				SQL = &quot;update Events set acknowledged = 1, Ranking = ?, Response = ?, AckTimeStamp = GETDATE(), AckUsername = ? where RuleId = ?&quot;
				rows = system.db.runPrepUpdate(SQL, [ranking, response, username, ruleId], &quot;&quot;, tx, 0)
			else:
				print &quot;Ranking an acknowledged alert!&quot;
				SQL = &quot;update Events set Ranking = ?, Response = ? where RuleId = ?&quot;
				rows = system.db.runPrepUpdate(SQL, [ranking, response, ruleId], &quot;&quot;, tx, 0)

	system.db.commitTransaction(tx)
	system.db.closeTransaction(tx)
		

# Insert a record into the event log and update the modelstatus table for a rule or model that just became bad.
def updateBadModel(id, database, debug):
	import app, system

	status = &quot;Bad&quot;
	tx = system.db.beginTransaction(timeout=5000, database = database)
	eventLogId = app.alerts.alert.insertEventLog(id, status, tx, debug)
					
	if debug:
		print &quot;The id for the new BAD status event is: &quot;, eventLogId
						
	# Update the RuleStatus table (which drives the Model Browser)
	app.alerts.alert.updateRuleStatus(id, eventLogId, status, tx, debug)

	system.db.commitTransaction(tx)
	system.db.closeTransaction(tx)


# This performs an update of the rule status table, which drives the Model Browser UI.
def updateRuleStatus(ruleId, eventLogId, status, tx, debug):
	import app, system

	if debug:
		print &quot;Setting the model %i (event = %i) status to %s&quot; % (ruleId, eventLogId, status)

	SQL = &quot;update RuleStatus set eventLogId = ?, Status = ?, EventTimeStamp = GETDATE() where RuleId = ?&quot;
	rows = system.db.runPrepUpdate(SQL, [ eventLogId, status, ruleId], &quot;&quot;, tx, 0)


# This version is used for every status other than true becuse they don&apos;t have an explanation
def insertEventLog(ruleId, status, tx, debug):
	import app, system

	if debug:
		print &quot;Inserting a %s event into EventLog for model %i&quot; % (status, ruleId)

	SQL = &quot;insert into EventLog (RuleId, Status, EventTimeStamp) values (?, ?, GETDATE())&quot;
	eventLogId = system.db.runPrepUpdate(query = SQL, args = [ ruleId, status ], tx = tx, getKey = 1)

	return eventLogId
	

# This version is used for every status other than true becuse they don&apos;t have an explanation
# We have gone back on forth on storing the descripotion and explanation, which may have dynamic text in it into the
# Event log to store the actual text that was displayed to the operator.  We decided to not store it in this version of RAP,
# but I will keep the args in the argument signature but will not use them (for now). 
def insertAlertIntoEventLog(ruleId, status, description, explanation, tx, debug):
	import app, system

	if debug:
		print &quot;Inserting an alert into the event log for model %i, status = %s&quot; % (ruleId, status)

	SQL = &quot;insert into EventLog (RuleId, Status, EventTimeStamp) values (?, ?, GETDATE())&quot;
	eventLogId = system.db.runPrepUpdate(query = SQL, args = [ ruleId, status ], tx = tx, getKey = 1)
	
	return eventLogId


# Insert the event detail record.  This is effectively a case statement.
def insertEventDetail(eventLogId, modelType, ruleId, status, description, explanation, tx, result, debug):
	import app, system
	
	if debug:
		print &quot;Inserting an alert into the event log for model %i, status = %s&quot; % (ruleId, status)

	if string.upper(modelType) == &quot;PCA&quot;:
		app.pca.eventDetail.insert(eventLogId, ruleId, status, description, explanation, tx, result, debug)
		
	return


# Fetch the number of old comments and new comments for rule.  We distinguish between
# old and new for the response column of the event browser.
def fetchCommentCounts(id, eventId):
	import system
	
	SQL = &quot;select count(*) from commentLog where RuleId = &quot; + str(id)
	numComments = system.db.runScalarQuery(SQL)
	
	SQL = &quot;select count(*) from commentLog where EventLogId = &quot; + str(eventId)
	numNewComments = system.db.runScalarQuery(SQL)
	
	numOldComments = numComments - numNewComments
	
	return numOldComments, numNewComments
	

# Format the 3 line response text string that goes in the alert browser.
# The first line is the number of comments entered against the current alert
# The second line is the number of comments entered against the same model but a previous alert
# The third line is the ranking 
def formatResponse(numOldComments, numNewComments, ranking):
	
	if numNewComments &gt; 0:
		response = &quot;&lt;HTML&gt;&quot; + str(numNewComments) + &quot; current&lt;br&gt;&quot;
	else:
		response = &quot;&lt;HTML&gt; &lt;br&gt;&quot;

	if numOldComments &gt; 0:
		response = response + str(numOldComments) + &quot; old&lt;br&gt;&quot;
	else:
		response = response + &quot; &lt;br&gt;&quot;

	response = response + ranking

	return response
	

# Insert a comment that was initiated from an event.
def insertEventComment(eventLogId, ruleId, comment, userId):
	import app, system
		
	print &quot;In insertEventComment()...&quot;

	SQL = &quot;insert into CommentLog (EventLogId, RuleId, CommentAuthorId, CommentTimestamp, Comment) values (?, ?, ?, GETDATE(), ?)&quot;
	eventLogId = system.db.runPrepUpdate(query = SQL, args = [ eventLogId, ruleId, userId, comment ])


# Insert a comment that was initiated from a rule.
def insertRuleComment(ruleId, comment, userId):
	import app, system
			
	print &quot;In insertRuleComment()...&quot;
	
	SQL = &quot;insert into CommentLog (RuleId, CommentAuthorId, CommentTimestamp, Comment) values (?, ?, ?, GETDATE(), ?)&quot;
	eventLogId = system.db.runPrepUpdate(query = SQL, args = [ ruleId, userId, comment ])


def fetchDestinations(ruleId):
	import system
	
	SQL = &quot;select D.Name from Destination D, RuleDestination RD&quot;
	SQL = SQL + &quot; where RD.RuleId = ? and D.destinationId = RD.destinationID order by name&quot;

	pds = system.db.runPrepQuery(query = SQL, args = [ruleId])

	destinations = &quot;&quot;
	for row in pds:
		if destinations == &quot;&quot;:
			destinations = row[0]
		else:
			destinations = destinations + &quot;, &quot; + row[0]
	
#	print destinations

	return destinations

#
# This is called whenever a model becomes false.  It deletes the alert from the Events table if the model is false and the
# alert has never been shown to the operator.  
#
def deleteIfNeverShown(ruleId, database, debug):
	import app, system
	
	if debug:
		print &quot;In deleteIfNeverShown with rule or model id: &quot;, ruleId
	
	tx = system.db.beginTransaction(timeout=5000, database = database)

	SQL = &quot;delete from Events where RuleId = ? and Shown = 0&quot;

	rows = system.db.runPrepUpdate(query = SQL, args = [ruleId], tx = tx)
	system.db.commitTransaction(tx)
	system.db.closeTransaction(tx)

	if rows &gt; 0:
		if debug:	
			print &quot;Deleted the event from Events because it was never shown&quot;

		app.engine.common.logEvaluationNote(ruleId, &quot;Model&quot;, &quot;Deleted the event from Events because it was never shown&quot;, database)</str>
				</o-c>
				<o-c m="put" s="2;O;O">
					<str>diagnostics.classes.BasicBlock</str>
					<str>#  Copyright 2013 ILS Automation
#
# This class an abstract base class for all blocks in
# diagnostics diagrams.
#
class BasicBlock():
	# Properties are a dictionaty of attributes keyed by name
	properties = {&apos;class&apos;:{&apos;value&apos;:&apos;app.diagnostics.classes.BasicBlock&apos;,&apos;readonly&apos;:True}}
	
	# Input ports are named stubs for incoming connections
	inports = []
	# Outports are named stubs for outgoing connections
	outports = []
	
	# Return a list of property names. 
	def getPropertyNames():
		return properties.getKeys()
		
	# Return a specified property. The property
	# is a dictionary guaranteed to have a &quot;value&quot;. 
	def getPropertyName(name):
		properties.get(name,{})
		
	# Accept notification that a value has arrived on an input
	# The default implementation does nothing
	def setValue(value,port):
		pass
	
	# Evaluate the block. This default implementation
	# does nothing.
	def evaluate():
		pass
		</str>
				</o-c>
				<o-c m="put" s="2;O;O">
					<str>diagnostics.alerts.checkAckRights</str>
					<str># Check if the username has the correct rights for acknowledging (or Ranking) an alert.
def checkAckRights(ruleId, username):
	import system
	
	SQL = &quot;select count(*) &quot;
	SQL = &quot;%s from RuleDestination RD, UserRTSubscription URS, Users U &quot; % (SQL)
	SQL = &quot;%s where RD.RuleID = %i &quot; % (SQL, ruleId)
	SQL = &quot;%s and RD.destinationID = URS.destinationId &quot; % (SQL)
	SQL = &quot;%s and URS.UserID = U.UserId &quot; % (SQL)
	SQL = &quot;%s and U.username = &apos;%s&apos;&quot; % (SQL, username)

	cnt = system.db.runScalarQuery(SQL)
	
	if cnt &gt; 0:
		return True
	
	return False</str>
				</o-c>
				<o-c m="put" s="2;O;O">
					<str>diagnostics.alerts.destinations</str>
					<str># Reset the current user destination subscriptions to the permanent ones.  This gets called on startup and
# at the end of a shift.
def reset():
	import app, system
	
	DB = &quot;AED_DB&quot;

	SQL = &quot;delete from UserCurrentSubscription&quot;
	rows = system.db.runUpdateQuery(SQL, DB)
	print &quot;Deleted %i rows from UserCurrentSubscription&quot; % (rows)
	
	SQL = &quot;insert into UserCurrentSubscription (UserID, DestinationID) select UserID, DestinationID from UserRTSubscription&quot; 
	rows = system.db.runUpdateQuery(SQL, DB)
	print &quot;Inserted %i rows into UserCurrentSubscription&quot; % (rows)


# Reset the current user destination subscriptions to the permanent ones for a specific user.  This is called from the &quot;Reset&quot;
# button on the destination editor screen.  This just updates the right list, the left list updates itself.  This does not reset
# the database tables until the user presses OK.
def resetUser(event):
	import app, system
	
	username = system.tag.read(&quot;[System]Client/User/Username&quot;).value
	
	SQL = &quot;SELECT D.name, D.destinationId &quot;
	SQL = &quot;%s FROM Destination D, UserRTSubscription US, Users U&quot; % (SQL)	
	SQL = &quot;%s WHERE D.destinationID = US.destinationID&quot; % (SQL)	
	SQL = &quot;%s and US.userId = U.UserID&quot; % (SQL)	
	SQL = &quot;%s and U.username = &apos;%s&apos;&quot; % (SQL, username)	
	SQL = &quot;%s order by D.name&quot; % (SQL)	
	
	pds = system.db.runQuery(SQL)
	print pds

	list = event.source.parent.getComponent(&quot;Right List&quot;)
	list.data = pds

	SQL = &quot;SELECT name, destinationId &quot;
	SQL = &quot;%s FROM Destination &quot; % (SQL)	
	SQL = &quot;%s WHERE destinationId not in (select distinct US.destinationId &quot; % (SQL)	
	SQL = &quot;%s from UserRTSubscription US, Users U&quot; % (SQL)	
	SQL = &quot;%s where US.userId = U.UserID&quot; % (SQL)	
	SQL = &quot;%s and U.username = &apos;%s&apos;)&quot; % (SQL, username)
	SQL = &quot;%s order by name&quot; % (SQL)

	pds = system.db.runQuery(SQL)
	print pds
	
	list = event.source.parent.getComponent(&quot;Left List&quot;)
	list.data = pds


def saveTemporarySubscriptions(event):
	import system
	
	print &quot;Saving the destination subscriptions...&quot;

	username = system.tag.read(&quot;[System]Client/User/Username&quot;).value
	SQL = &quot;select userid from users where username = &apos;%s&apos;&quot; % ( username )
	print SQL
	userId = system.db.runScalarQuery(SQL)
	print &quot;User Id: &quot;, userId
	
	SQL = &quot;delete from userCurrentSubscription where userId = %i&quot; % (userId)
	print SQL
	rows = system.db.runUpdateQuery(SQL)
	print &quot;Deleted %i current subscriptions&quot; % (rows) 

	# Get the right list widget
	list = event.source.parent.getComponent(&apos;Right List&apos;)	
	ds = list.data
	pds = system.dataset.toPyDataSet(ds)

	totalRows = 0
	for record in pds:
		destinationId = record[&quot;destinationId&quot;]
		
		SQL = &quot;insert into userCurrentSubscription (userId, destinationId) values (%i, %i)&quot; % (userId, destinationId)
		print SQL
		rows = system.db.runUpdateQuery(SQL)
		totalRows = totalRows + rows

	print &quot;Added %i current subscriptions&quot; % (totalRows)


# Refresh any open event browsers to use the new temporary subscriptions.  Most of the browsers update on a 5 second poll, so even if we 
# don&apos;t refresh them here they will update on average in 2.5 seconds.  The big exception is the historical event browser,
# which never updates (because it is historical).   
def refresh(event):
	import system
	
	print &quot;Refreshing browser...&quot;
	
	ds = event.source.parent.sourceBrowser
	print ds
	if ds.rowCount &gt; 0:
		print &quot;There is a browser to update!&quot;
		table = ds.getValueAt(0,0)

		# All of the browsers have the SQL built into their rawData property except the historical browser.
		rawData = table.getPropertyValue(&quot;rawData&quot;)
		if rawData == None:
			system.db.refresh(table, &quot;data&quot;)
		else:
			system.db.refresh(table, &quot;rawData&quot;)</str>
				</o-c>
				<o-c m="put" s="2;O;O">
					<str>diagnostics.blocks</str>
					<str># Copyright 2013 ILS Automation
#
# Return a dictionary of attributes and values for
# a specified block. If the block is not currently in the
# repository, create it.
#
# Arguments:
#    proj - project Id
#    path - nav tree path to the diagram
#    index- block number within the diagram
def getAttributeDictionary(proj,path,index):
	import  app, system</str>
				</o-c>
				<o-c m="put" s="2;O;O">
					<str>diagnostics.alerts.alertBrowser</str>
					<str>def processData(table):
	import system
	
#	print &quot;Processing the raw data&quot;
	ds = table.rawData
	for row in range(ds.rowCount):
		name = ds.getValueAt(row, &quot;Name&quot;)
		description = ds.getValueAt(row, &quot;Description&quot;)
		rationale = ds.getValueAt(row, &quot;Rationale&quot;)

		if rationale == &quot;&quot;:
			message = &apos;&lt;HTML&gt;&apos; + name + &apos;:&apos; + description
		else:
			message = &apos;&lt;HTML&gt;&apos; + name + &apos;:&apos; + description + &apos;:&apos; + rationale

		ds = system.dataset.setValue(ds, row, 5, message)
	
	table.data = ds
			 
# This is the callback from all 3 of the ranking buttons on the alert browser
def rankCallback(event, ranking):
	import app, system

	type, ruleId, eventLogId = app.alerts.common.getSelectedEventInfo(event.source.parent.parent)

	if ruleId &gt; 0:
		app.alerts.alert.rank(eventLogId, ruleId, ranking)
		app.alerts.alertBrowser.refresh(event.source.parent.parent)
		
		rankingContainer = event.source.parent	

		# Diable all three of the ranking buttons
		rankingContainer.getComponent(&quot;Process Save Button&quot;).enabled = False
		rankingContainer.getComponent(&quot;Real No Save Button&quot;).enabled = False
		rankingContainer.getComponent(&quot;Not Useful Button&quot;).enabled = False		
	else:
		system.gui.messageBox(&quot;Please select an alert!&quot;)


# This is the callback from the acknowledge button on the alert browser
def acknowledgeCallback(event):
	import app, system

	type, ruleId, eventLogId = app.alerts.common.getSelectedEventInfo(event.source.parent)

	if ruleId &gt; 0:
		username = system.tag.read(&quot;[System]Client/User/Username&quot;).value
		okToDelete = app.alerts.checkAckRights.checkAckRights(ruleId, username)
		if okToDelete:
			app.alerts.alert.acknowledge(ruleId)
			app.alerts.alertBrowser.refresh(event.source.parent)
		else:
			system.gui.messageBox(&quot;Unable to acknowledge this model because you do not have a permanent subscription to its destinations!&quot;)
	else:
		system.gui.messageBox(&quot;Please select an alert!&quot;)


# This is the callback from the comment browser button on the alert browser
def commentBrowserCallback(event):
	import app, system
	
	window = system.gui.getParentWindow(event)

	if window.title == &quot;Historic Event Browser&quot;:
		type, ruleId, eventLogId = app.alerts.common.getSelectedHistoricEventInfo(event.source.parent)
	else:
		type, ruleId, eventLogId = app.alerts.common.getSelectedEventInfo(event.source.parent)

	if ruleId &gt; 0:
		system.nav.openWindowInstance(&quot;Alert Displays/Comment Browser&quot;, {&quot;eventLogId&quot;: eventLogId, &quot;modelId&quot;: ruleId, &quot;title&quot;: type + &quot; Comment Browser for id:&quot; + str(ruleId)})
	else:
		system.gui.messageBox(&quot;Error opening the comment browser - unable to get the model id for the selected alert!&quot;)

				
# This is the callback from the unsuppress button on the Suppressed Event Browser
def unsuppressCallback(event):	
	import app

	type, ruleId, eventLogId = app.alerts.common.getSelectedEventInfo(event.source.parent)
	if type == -1:
		return;
	app.alerts.alert.manualUnsuppress(ruleId)
	app.alerts.alertBrowser.refresh(event.source.parent)


# This is the callback from the &quot;Confirm&quot; button on the Suppressed Event Browser
def confirmManualSuppressionCallback(event):	
	import app

	type, ruleId, eventLogId = app.alerts.common.getSelectedEventInfo(event.source.parent)
	if type == -1:
		return;
	app.alerts.alert.confirmManualSuppression(ruleId)


# This is the callback from the Show Details button on the Historic Alert Browser.
def showHistoricDetailCallback(event):
	import app, system
	print &quot;In showHistoricDetailCallback()&quot;
	
	# Get the date from the selected row.
	table = event.source.parent.getComponent(&quot;Table&quot;)
	ds = table.data
	pds = system.dataset.toPyDataSet(ds)

	eventLogId = pds[table.selectedRow][&quot;EventLogID&quot;]
	type = pds[table.selectedRow][&quot;Type&quot;]
	ruleId = pds[table.selectedRow][&quot;ID&quot;]
	name = pds[table.selectedRow][&quot;Name&quot;]
	ackd = True
	
	if (type == &apos;PID&apos;):
		system.nav.openWindowInstance(&quot;Alert Displays/PID Alert Display&quot;, {&quot;eventLogId&quot;: eventLogId, &quot;ruleId&quot;: ruleId, &quot;title&quot;: name + &quot; Alert Display&quot;, &quot;ackd&quot;: ackd})
	elif (type == &apos;VFM&apos;):
		system.nav.openWindowInstance(&quot;Alert Displays/VFM Alert Display&quot;, {&quot;eventLogId&quot;: eventLogId, &quot;ruleId&quot;: ruleId, &quot;title&quot;: name + &quot; Alert Display&quot;, &quot;ackd&quot;: ackd})
	elif (type == &apos;VAR&apos;):
		system.nav.openWindowInstance(&quot;Alert Displays/VAR Alert Display&quot;, {&quot;eventLogId&quot;: eventLogId, &quot;ruleId&quot;: ruleId, &quot;title&quot;: name + &quot; Alert Display&quot;, &quot;ackd&quot;: ackd})
	elif (type == &apos;PCA&apos;):
		system.nav.openWindowInstance(&quot;Alert Displays/PCA Alert Display&quot;, {&quot;eventLogId&quot;: eventLogId, &quot;ruleId&quot;: ruleId, &quot;title&quot;: name + &quot; Alert Display&quot;, &quot;ackd&quot;: ackd})
	elif (type == &apos;Rule&apos;):
		system.nav.openWindowInstance(&quot;Alert Displays/Rule Alert Display&quot;, {&quot;eventLogId&quot;: eventLogId, &quot;ruleId&quot;: ruleId, &quot;title&quot;: name + &quot; Alert Display&quot;, &quot;ackd&quot;: ackd})
	else:
		system.gui.messageBox(&quot;An Alert Display does not exist for a &quot; + type + &quot; model!&quot;,&quot;Alert Detail Error&quot;)


# This is the callback from the Show Details button on the Alert Browser.
def showDetailCallback(event):
	import app, system
	print &quot;In showDetailCallback()&quot;

	type, ruleId, eventLogId = app.alerts.common.getSelectedEventInfo(event.source.parent)
	if type == -1:
		return;

	# Determine if the selected row has been ACK&apos;d, the &apos;Show Details&apos; button is the originator of the event.
	table = event.source.parent.getComponent(&quot;Table&quot;)
	ds = table.data
	pds = system.dataset.toPyDataSet(ds)
	ackd = pds[table.selectedRow][&quot;Acknowledged&quot;]
	
	# Fetch the entire alert record and pass it to the alert display		
	pds, ds = app.alerts.common.fetchAlertDB(ruleId, &quot;&quot;)
	if ds.rowCount != 1:
		system.gui.warningBox(&quot;Alert details could not be found for this alert&quot;)
		return;
		
	print &quot;Got the event record...&quot;
	record = pds[0]	

	if (type == &apos;PID&apos;):
		system.nav.openWindowInstance(&quot;Alert Displays/PID Alert Display&quot;, {&quot;eventLogId&quot;: eventLogId, &quot;ruleId&quot;: ruleId, &quot;title&quot;: record[&quot;Name&quot;] + &quot; Alert Display&quot;, &quot;ackd&quot;: ackd})
	elif (type == &apos;VFM&apos;):
		system.nav.openWindowInstance(&quot;Alert Displays/VFM Alert Display&quot;, {&quot;eventLogId&quot;: eventLogId, &quot;ruleId&quot;: ruleId, &quot;title&quot;: record[&quot;Name&quot;] + &quot; Alert Display&quot;, &quot;ackd&quot;: ackd})
	elif (type == &apos;VAR&apos;):
		system.nav.openWindowInstance(&quot;Alert Displays/VAR Alert Display&quot;, {&quot;eventLogId&quot;: eventLogId, &quot;ruleId&quot;: ruleId, &quot;title&quot;: record[&quot;Name&quot;] + &quot; Alert Display&quot;, &quot;ackd&quot;: ackd})
	elif (type == &apos;PCA&apos;):
		system.nav.openWindowInstance(&quot;Alert Displays/PCA Alert Display&quot;, {&quot;eventLogId&quot;: eventLogId, &quot;ruleId&quot;: ruleId, &quot;title&quot;: record[&quot;Name&quot;] + &quot; Alert Display&quot;, &quot;ackd&quot;: ackd})
	elif (type == &apos;Rule&apos;):
		system.nav.openWindowInstance(&quot;Alert Displays/Rule Alert Display&quot;, {&quot;eventLogId&quot;: eventLogId, &quot;ruleId&quot;: ruleId, &quot;title&quot;: record[&quot;Name&quot;] + &quot; Alert Display&quot;, &quot;ackd&quot;: ackd})
	else:
		system.gui.messageBox(&quot;An Alert Display does not exist for a &quot; + type + &quot; model!&quot;,&quot;Alert Detail Error&quot;)

	# There is an acknowldegment that will happen in the detail screen and this should refresh this browser
	app.alerts.alertBrowser.refresh(event.source.parent)
	table.selectedRow = -1

# Enable or disable the browser toolbar buttons that are based on conditionally selecting a row.
def enableOrDisableButtons(event):
	import app, system

	# Get the root container
	parent = event.source.parent

	# The table is the source of the event
	table = event.source
	row = table.selectedRow

	buttons = [&quot;Acknowledge Button&quot;, &quot;Show Details Button&quot;, &quot;Unsuppress Button&quot;, &quot;Comment Button&quot;]

	if (row &gt;= 0):
		# Update the detail field
		dataSet = table.data
		pDataSet = system.dataset.toPyDataSet(dataSet)

		# Determine if the alarm has been acknowledged
		ackd = pDataSet[row][&quot;Acknowledged&quot;]

		# Enable all of the buttons that require a row selection
		for buttonLabel in buttons:
			if buttonLabel == &quot;Acknowledge Button&quot; and ackd:
				app.alerts.alertBrowser.enableOrDisableButton(parent, buttonLabel, False)
			else:
				app.alerts.alertBrowser.enableOrDisableButton(parent, buttonLabel, True)
	
	else:
		# Disable all of the buttons that require a row selection
		for buttonLabel in buttons:
			app.alerts.alertBrowser.enableOrDisableButton(parent, buttonLabel, False)


# Enable or Disable the button	
def enableOrDisableButton(parent, buttonLabel, action):	
	import app
	
	try:
		button = parent.getComponent(buttonLabel)
		button.enabled = action
	except:
		pass

	
# Enable or disable the browser toolbar buttons that are based on conditionally selecting a row.
def updateDetailField(event):
	import app, system
		
	# Get the root container
	parent = event.source.parent
		
	# The table is the source of the event
	table = event.source
	row = table.selectedRow
		
	# Get the detail field at the bottom of the browser
	detailField = parent.getComponent(&apos;Alert Details&apos;)

	if (row &gt;= 0):
		# Update the detail field
		ds = table.data
		pds = system.dataset.toPyDataSet(ds)
								
		# Get the alert details from the last (idx = 8) column which is hidden
		alertDetails = pds[row][&quot;Explanation&quot;]
		detailField.text = alertDetails
			
	else:
		# Clear the detail field			
		detailField.text = &quot;&quot;	


# Enable or disable the ranking buttons.  Enable them only if a an unranked row is selected.
# If a ranked row is selected, then select the appropriate button
# This is called 
def enableOrDisableRanking(event):
	import app, system

	# Get the root container
	parent = event.source.parent
	rankingContainer = parent.getComponent(&quot;Ranking Container&quot;)	

	# The table is the source of the event
	table = event.source
	row = table.selectedRow

	if row &gt;= 0:
		ds = table.data
		pds = system.dataset.toPyDataSet(ds)
		ranking = pds[row][&quot;Ranking&quot;]
		print &quot;The ranking is: &quot;, ranking
		if ranking == &quot;&quot; or ranking == None:
			print &quot;Enabling all&quot;
			rankingContainer.getComponent(&quot;Process Save Button&quot;).enabled = True
			rankingContainer.getComponent(&quot;Real No Save Button&quot;).enabled = True
			rankingContainer.getComponent(&quot;Not Useful Button&quot;).enabled = True
			
			# It is hard to unselect Radio buttons, my trick is to add a 4th button and hide it.
			rankingContainer.getComponent(&quot;No Selection Button&quot;).selected = True
		else:
			print &quot;Setting&quot;
			app.alerts.alertBrowser.disableAndSelectRanking(rankingContainer, ranking)

	else:
		app.alerts.alertBrowser.disableAndSelectRanking(rankingContainer, &quot;&quot;)
		# It is hard to unselect Radio buttons, my trick is to add a 4th button and hide it.
		rankingContainer.getComponent(&quot;No Selection Button&quot;).selected = True


def disableAndSelectRanking(rankingContainer, ranking):

	# Process Save Button
	rankingContainer.getComponent(&quot;Process Save Button&quot;).enabled = False
	if ranking == &quot;Process Save&quot;:
		rankingContainer.getComponent(&quot;Process Save Button&quot;).selected = True
	else:
		rankingContainer.getComponent(&quot;Process Save Button&quot;).selected = False
	
	# Real No Save Button
	rankingContainer.getComponent(&quot;Real No Save Button&quot;).enabled = False
	if ranking == &quot;Real No Save&quot;:
		rankingContainer.getComponent(&quot;Real No Save Button&quot;).selected = True
	else:
		rankingContainer.getComponent(&quot;Real No Save Button&quot;).selected = False

	# Not Usefule Button
	rankingContainer.getComponent(&quot;Not Useful Button&quot;).enabled = False
	if ranking == &quot;Not Useful&quot;:
		rankingContainer.getComponent(&quot;Not Useful Button&quot;).selected = True
	else:
		rankingContainer.getComponent(&quot;Not Useful Button&quot;).selected = False

# This is commonly called from the callback of a button after some other processing and 
# database transactions have occurred.  It will cause the instant update of the table!
# This will refresh the browsers table regardless of which browser is used.	
def refresh(rootContainer):
	import system

	# the detail field is also part of the template
	table = rootContainer.getComponent(&apos;Table&apos;)
	system.db.refresh(table, &quot;data&quot;)


def fetchDestinationSubscriptionIds(userName):
	import system

	SQL = &quot;select destinationId from UserRtSubscription URS, Users U&quot;
	SQL = SQL + &quot; where U.UserId = URS.UserId and U.UserName = &apos;&quot; + userName + &quot;&apos;&quot;
	
	pds = system.db.runQuery(query = SQL)

	destinations = &quot;&quot;
	for row in pds:
		if destinations == &quot;&quot;:
			destinations = str(row[0])
		else:
			destinations = destinations + &quot;, &quot; + str(row[0])
	
	# Need to gracefully handle the case where there are no subscriptions
	if destinations == &quot;&quot;:
		destinations = &quot;( -1 )&quot;
	else:
		destinations = &quot;(&quot; + destinations + &quot;)&quot;
 
	print &quot;Destinations: &quot; + destinations

	return destinations	 </str>
				</o-c>
				<o-c m="put" s="2;O;O">
					<str>diagnostics.alertDisplays.callbacks</str>
					<str># This is the callback that TOGGLES the suppression.  It is called to Suppress and to Unsuppress.  
# There is a single toggle button used to perform bgoth functions
def suppressCallback(event):
	import app, system

	rootContainer = event.source.parent
	ruleId = rootContainer.ruleId

	# Don&apos;t trust the state of the button - check what the actual state is in the database
	pds, ds = app.alerts.common.fetchAlertDB(ruleId, &quot;&quot;)
	if ds.rowCount != 1:
		system.gui.warningBox(&quot;The alert is no longer active and therefore cannot be suppressed - it has been deleted.&quot;)
		return;

	record = pds[0]
	manuallySuppressed = record[&quot;ManuallySuppressed&quot;]

	if manuallySuppressed:
		print &quot;Unsuppressing!!&quot;
		app.alerts.alert.manualUnsuppress(ruleId)
	else:
		print &quot;Suppressing&quot;
		app.alerts.alert.manualSuppress(ruleId)
	
	# Now read back from the database and set the button state accordingly.
	pds, ds = app.alerts.common.fetchAlertDB(ruleId, &quot;&quot;)
	if ds.rowCount != 1:
		system.gui.warningBox(&quot;Unable to suppress or unsuppress because Alert details could not be found for this alert&quot;)
		return;
	
	record = pds[0]
	rootContainer.manuallySuppressed = record[&quot;ManuallySuppressed&quot;]
	
	
def processSaveCallback(event):
	import app
	app.alertDisplays.callbacks.rankingCallback(event, &quot;Process Save&quot;)

def realNoSaveCallback(event):
	import app
	app.alertDisplays.callbacks.rankingCallback(event, &quot;Real No Save&quot;)

def notUsefulCallback(event):
	import app
	app.alertDisplays.callbacks.rankingCallback(event, &quot;Not Useful&quot;)

def rankingCallback(event, ranking):
	import app, system

	print &quot;Handling a &quot; + ranking + &quot; alert ranking!&quot;
	rootContainer = event.source.parent
	id = rootContainer.RuleId
		
	alert = app.alerts.common.fetchAlertDB(id)
	print &quot;AlertDB: &quot;, alert
	
	ackTimeStamp = alert[&apos;AckTimeStamp&apos;]
	eventLogId = alert[&apos;EventLogId&apos;]
	response = &quot;&lt;HTML&gt;&lt;BR&gt;&lt;BR&gt;&quot; + ranking

	txId = system.db.beginTransaction(timeout=5000)
	
	# if the alert is not acknowledged then a ranking should also do an acknowledgement
	if ackTimeStamp == None:
		print &quot;Ranking an alert that has NOT been acknowledged...&quot;
		userName, userId = app.alerts.common.getUsername(event)
		print &quot;Username: &quot;, userName
		print &quot;Id: &quot;, userId

		SQL = &quot;update Events set ranking = ?, Acknowledged = 1, AckTimeStamp = GETDATE(), AckUsername = ?, Response = ? where RuleId = ?&quot;
		rows = system.db.runPrepUpdate(SQL, [ranking, userName, response, id], &quot;&quot;, txId, 0)

		SQL = &quot;update EventLog set ranking = ?, AcknowledgedBy = ?, AckTimeStamp = GETDATE() where EventLogId = ?&quot;
		rows = system.db.runPrepUpdate(SQL, [ranking, userId, eventLogId], &quot;&quot;, txId, 0)
	else:
		print &quot;Ranking an alert that has already been acknowledged!&quot;
		SQL = &quot;update Events set ranking = ?, Response = ? where RuleId = ?&quot;
		rows = system.db.runPrepUpdate(SQL, [ranking, response, id], &quot;&quot;, txId, 0)
		
		SQL = &quot;update EventLog set ranking = ? where EventLogId = ?&quot;
		rows = system.db.runPrepUpdate(SQL, [ranking, eventLogId], &quot;&quot;, txId, 0)

	system.db.commitTransaction(txId)
	system.db.closeTransaction(txId)
	
#
# This is the callback from the comment browser button on the alert browser
def commentBrowserCallback(event):
	import app, system
	
	rootContainer = event.source.parent

	eventLogId = rootContainer.eventLogId
	ruleId = rootContainer.ruleId
	type = rootContainer.modelType

	if ruleId &gt; 0:
		# Fetch the entire alert record and pass it to the alert display		
		pds, ds = app.alerts.common.fetchAlertDB(ruleId, &quot;&quot;)
		if ds.rowCount != 1:
			system.gui.warningBox(&quot;Alert details could not be found for this alert&quot;)
			return;
			
		print &quot;Got the event record...&quot;
		record = pds[0]
		
		if ruleId &gt; 0:
			system.nav.openWindowInstance(&quot;Alert Displays/Comment Browser&quot;, {&quot;eventLogId&quot;: eventLogId, &quot;modelId&quot;: ruleId, &quot;title&quot;: record[&quot;Name&quot;] + &quot; Comment Browser&quot;})

	else:
		system.gui.messageBox(&quot;Please select an alert!&quot;)</str>
				</o-c>
				<o-c m="put" s="2;O;O">
					<str>diagnostics.menu</str>
					<str># Copyright 2013 ILS Automation
#
# Enable or disable menuitems per the user role.
# The argument is a menubar component.
#
def enableMenuItemsPerUserRole(bar):
	import app
	#
	# For our purposes all we care about is engineer vs operator
	isEngineer = app.ils.user.hasRole(&apos;DiagnosticsToolkit&apos;,&apos;engineer&apos;)
	count = bar.getMenuCount()
	index = 0
	while index&lt;count:
		menu = bar.getMenu(index)
		name = menu.getText()
		print &quot;Menu:&quot;,name
		if name== &apos;View&apos;:
			if isEngineer==True:
				app.diagnostics.menu.delete(menu,&apos;Event Log&apos;)
				app.diagnostics.menu.delete(menu,&apos;Recommendations&apos;)
			else:
				app.diagnostics.menu.delete(menu,&apos;Diagrams&apos;)
				app.diagnostics.menu.delete(menu,&apos;Data Pump&apos;)
		index=index+1
		
# Given a menu, delete a menuitem of a given name
def delete(menu,childName):
	count = menu.getItemCount()
	index = 0
	while index&lt;count:
		submenu = menu.getItem(index)
		name = submenu.getText()
		if name==childName:
			menu.remove(submenu)
			break;
		index=index+1</str>
				</o-c>
				<o-c m="put" s="2;O;O">
					<str>diagnostics.alertDisplays.common</str>
					<str># Set the ranking button state when the alert dispollay is opened.  The rule with ranking is that they
# cannot be changed.  Once an alert is ranked, it is ranked!  Because it is a little difficult to 
# unselect all of the buttons of a group, I added a 4th hidden button, which I can select which will
# automatically unselect the three visible buttons.
def setRankingButtonState(rootContainer, ranking):
	import system

	template = rootContainer.getComponent(&quot;Ranking Buttons&quot;)

	if ranking == &quot;Process Save&quot; or ranking == &quot;Real No Save&quot; or ranking == &quot;Not Useful&quot;:
		print &quot;Setting the ranking button state() to &quot;, ranking
		template.noSelection = False
		template.enableRanking = False
		
		if ranking == &quot;Process Save&quot;:
			template.processSave = True
			template.realNoSave = False
			template.notUseful = False
		elif ranking == &quot;Real No Save&quot;:
			template.processSave = False
			template.realNoSave = True
			template.notUseful = False
		elif ranking == &quot;Not Useful&quot;:
			template.processSave = False
			template.realNoSave = False
			template.notUseful = True
		
	else:
		print &quot;*** There is NO ranking ***&quot;
		template.processSave = False
		template.realNoSave = False
		template.notUseful = False
		template.noSelection = True

		template.enableRanking = True

#
def fetchReferences(modelId, conclusionId):
	import system
	
	if modelId &gt; 0:
		SQL = &quot;select location from Reference where modelId = ?&quot;
		pds = system.db.runPrepQuery(SQL, [modelId])
	else:
		SQL = &quot;select location from Reference where conclusionId = ?&quot;
		pds = system.db.runPrepQuery(SQL, [conclusionId])

	ds = system.dataset.toDataSet(pds)

	return ds


# The event MUST come from the button inside the Ranking Buttons template
# There are two things that can be saved, ranking and comments.
# Engineers may enter comments, but only operator may rank and acknowledge
def save(event):
	import app, system
	
	print &quot;Saving the ranking and comments...&quot;
	container = event.source.parent
	template = container.parent
	rootContainer = template.parent.parent
	
	comments = container.getComponent(&quot;Comments&quot;).text
	username = container.getComponent(&quot;Operator Dropdown&quot;).selectedStringValue

	if comments != &quot;&quot; and (username == None or username == &quot;&quot;):
		system.gui.warningBox(&quot;Please select a username when entering a comment!&quot;)
		return False
	
	eventLogId = rootContainer.eventLogId
	ruleId = rootContainer.ruleId
	modelName = rootContainer.getPropertyValue(&quot;modelName&quot;)
	description = rootContainer.getPropertyValue(&quot;description&quot;)
	eventTime = rootContainer.getPropertyValue(&quot;eventTime&quot;)
	rationale = rootContainer.getPropertyValue(&quot;rationale&quot;)

	# Remember that ranking cannot be changed, once an alert is ranked it is permanent.  The easiest way to tell if
	# an alert was previously ranked is to check if ranking is enabled on the template.  If it is then see if they
	# have ranked the alert, they could have just entered a comment
	if template.enableRanking and &quot;RTA.Operators.GG&quot; in system.security.getRoles():
		if container.getComponent(&quot;Process Save Button&quot;).selected:
			ranking = &quot;Process Save&quot;
		elif container.getComponent(&quot;Real No Save Button&quot;).selected:
			ranking = &quot;Real No Save&quot;
		elif container.getComponent(&quot;Not Useful Button&quot;).selected:
			ranking = &quot;Not Useful&quot;
		else:
			ranking = None

		if ranking != None:
			print &quot;Updating the ranking...&quot;
			app.alerts.alert.rank(eventLogId, ruleId, ranking)

	if comments != &quot;&quot;:	
		print &quot;Comments: &quot;, comments
		print &quot;Username: &quot;, username
		
		userId = container.getComponent(&quot;Operator Dropdown&quot;).selectedValue
		app.alerts.alert.insertEventComment(eventLogId, ruleId, comments, userId)
		
		# Send a comment E-Mail
		app.alerts.email.newComment(ruleId, modelName, comments, username, description, rationale, eventTime)
		
		# Once the comment has been saved, clear it out
		container.getComponent(&quot;Comments&quot;).text = &quot;&quot;

		# Fetch the comment counts and get the ranking so that we can format the response 3 line text string
		ranking = rootContainer.ranking
		if ranking == None:
			ranking = &quot;&quot;
		numOldComments, numNewComments = app.alerts.alert.fetchCommentCounts(ruleId, eventLogId)
		response = app.alerts.alert.formatResponse(numOldComments, numNewComments, ranking)
		print &quot;The reponse is: &quot; + response
	
		SQL = &quot;update Events set Response = ? where RuleId = ?&quot;
		system.db.runPrepUpdate( SQL, [ response, ruleId ] )

	return True

# Set the inner and outer date range for the date widget based on the current time and the time of 
# the event.  Remember that we set the date widget, not the chart.  This may not be intuitive at first,
# but the chart will plot everything that is in the dataset, so we bind the dataset to the date
# widget.
def setChartTime(eventTime, rootContainer):
	import app, system
	from java.util import Calendar
	from java.util import Date

	dateWidget = rootContainer.getComponent(&quot;Date Range&quot;)
	cal = Calendar.getInstance()

	# The window is in hours and the range is in days	
	dateWindow = system.tag.getTagValue(&quot;Global Settings/Alert Display Date Startup Selection&quot;)
	dateRange = system.tag.getTagValue(&quot;Global Settings/Alert Display Date Startup Range&quot;)

	print &quot;The date window is %i hours&quot; % (dateWindow)
	print &quot;The event time is: &quot;, eventTime
	
	# Get the current time	
	now = Date()
	cal.setTime(now)
	nowMS = cal.getTimeInMillis()

	cal.setTime(eventTime)
	eventMS = cal.getTimeInMillis()

	delta = abs(nowMS - eventMS)
	print &quot;Milliseconds between dates: &quot;, delta 

	# First, size the visible windoww
	# If the event is less than 1/2 of the window, then the event is fresh and put the end of the range to the current time
	if delta &lt; ((dateWindow / 2.0) * 60 * 60 * 1000):
		print &quot;Event is fresh!&quot;
		endTime = now

		cal.setTime(endTime)
		cal.add(Calendar.HOUR, int(-1 * dateWindow))
		startTime = cal.getTime()
	else:
		print &quot;Event is stale&quot;
		# Set the event time
		cal.setTime(eventTime)

		# Set the start time as (the dataWindow / 2.0) hours before the event
		cal.add(Calendar.HOUR, int(-1 * dateWindow / 2.0))
		startTime = cal.getTime()

		# Set the end time as (the dataWindow / 2.0) hours after the event
		cal.add(Calendar.HOUR, int(dateWindow))
		endTime = cal.getTime()

	# Put the start and stop into the date widget
	
	dateWidget.startDate = startTime
	dateWidget.endDate = endTime
#	rootContainer.startDate = startTime
#	rootContainer.endDate = endTime

	print &quot;Setting the date selection as: &quot;, startTime, &quot; to &quot;, endTime
#	return
	
	# Now set the outerrange of the date widget - we want the range to be set from the global &quot;Alert Display Date
	# Startup Range&quot;, so if the event
	# is less than half og the range old, then set the end time as now, otherwise center the event 
	# in the range window.
	print &quot;Now the Outer Range, the range size is %i days...&quot; % (dateRange)
	if delta &lt; ( (dateRange * 24 / 2.0) * 60 * 60 * 1000):
		print &quot;Event is fresh!&quot;
		endTime = now
			
		cal.setTime(endTime)
		cal.add(Calendar.HOUR, int(-1 * dateRange * 24))
		startTime = cal.getTime()
	else:
		print &quot;Event is stale&quot;
		# Set the event time
		cal.setTime(eventTime)
	
		# Set the start time as (the dateRange / 2.0) hours before the event
		cal.add(Calendar.HOUR, int(-1 * dateRange * 24 / 2.0))
		startTime = cal.getTime()
		
		# Set the end time as (the dateRange / 2.0) hours after the event
		cal.add(Calendar.HOUR, int(dateRange * 24))
		endTime = cal.getTime()

	print &quot;Setting the outer date range as: &quot;, startTime, &quot; to &quot;, endTime
	dateWidget.outerRangeStartDate = startTime
	dateWidget.outerRangeEndDate = endTime</str>
				</o-c>
				<o-c m="put" s="2;O;O">
					<str>diagnostics.alerts.common</str>
					<str>def getSelectedEventId(rootContainer):
	# This is commonly called from the callback of a button.  It returns the 
	# eventId of the selected row.

	import system

	# the detail field is also part of the template
	table = rootContainer.getComponent(&apos;Table&apos;)
	row = table.selectedRow
	
	ds = table.data
	pds = system.dataset.toPyDataSet(ds)
							
	# Get the event id from the first (idx = 0) column
	eventId = pds[row][&quot;EventLogId&quot;]
	
	return eventId

# This is commonly called from the callback of a button.  It returns the 
# type, ruleId, eventLogId of the selected row.
def getSelectedEventInfo(rootContainer):
	import system

	table = rootContainer.getComponent(&apos;Table&apos;)
	row = table.selectedRow
	
	if row == -1:
		return -1, -1, -1
	
	ds = table.data
	pds = system.dataset.toPyDataSet(ds)
							
	# Get the rule id from the fifth (idx = 4) column
	type = pds[row][&quot;Type&quot;]
	ruleId = pds[row][&quot;RuleId&quot;]
	eventLogId = pds[row][&quot;EventLogId&quot;]
	
	return type, ruleId, eventLogId

# This is commonly called from the callback of a button on the historic event broweser.  
# It returns the type, ruleId, eventLogId of the selected row.
def getSelectedHistoricEventInfo(rootContainer):
	import system
	
	table = rootContainer.getComponent(&apos;Table&apos;)
	row = table.selectedRow
		
	if row == -1:
		return -1, -1, -1
		
	ds = table.data
	pds = system.dataset.toPyDataSet(ds)
								
	# Get the rule id from the fifth (idx = 4) column
	type = pds[row][&quot;Type&quot;]
	ruleId = pds[row][&quot;ID&quot;]
	eventLogId = pds[row][&quot;EventLogID&quot;]
		
	return type, ruleId, eventLogId

# Caution needs to be used when querying this table because as soon as an alert is cleared and ack&apos;d 
# it will be deleted.  
def fetchEventInfo(eventLogId, txId):
	import system
	
	SQL = &quot;SELECT * from EventLog &quot;
	SQL = SQL + &quot; where EventLogId = &quot; + str(eventLogId)

	# This will bring back 0 or 1 rows
	pds = system.db.runQuery(SQL, tx = txId)
	ds = system.dataset.toDataSet(pds)
	
	return pds, ds


# This used to be called getEvent
# Caution needs to be used when querying this table because as soon as an alert is cleared and ack&apos;d 
# it will be deleted.  
def fetchAlertDB(ruleId, txId):
	import system

	SQL = &quot;select * from Events where RuleId = &quot; + str(ruleId)

	# This will bring back 0 or 1 rows
	pds = system.db.runQuery(SQL, tx = txId)
	ds = system.dataset.toDataSet(pds)

	return pds, ds


# This script uses data in the database to set the status of the rule.  This is generally called after a change of some sort to the 
# suppression of a rule.  This can be called after a suppressor has been added or deleted and it should look at all of the other 
# suppressors that may be present before determining the state.
def updateRuleStatus(ruleId, debug, tx):
	import app, system, string
	
	SQL = &quot;select Status from RuleStatus where ruleId = &quot; + str(ruleId)
	# This will bring back 0 or 1 rows
	pds = system.db.runQuery(SQL, tx = tx)
	if len(pds) == 0:
		return;

	status = pds[0][&quot;Status&quot;]
	
	if debug:
		print &quot;Updating the status of rule %i, the current status is %s&quot; % (ruleId, status)

	numSuppressors, manualCounter, automaticCounter, internalCounter, suppressionDescription = app.engine.suppression.querySuppressors(ruleId, debug)

	# If the rule is false or disabled, then suppression has no affect on the status
	status=string.upper(status)
	if status == &quot;TRUE&quot;:
		if numSuppressors &gt; 0:
			SQL = &quot;update RuleStatus set status = &apos;Suppressed&apos; where ruleId = &quot; + str(ruleId)
			rows = system.db.runUpdateQuery(SQL, &quot;&quot;, tx, 0)

	elif status == &quot;SUPPRESSED&quot;:
		if numSuppressors &lt;= 0:
			SQL = &quot;update RuleStatus set status = &apos;True&apos; where ruleId = &quot; + str(ruleId)
			rows = system.db.runUpdateQuery(SQL, &quot;&quot;, tx, 0)

	return</str>
				</o-c>
				<o-c m="put" s="2;O;O">
					<str>diagnostics.alertDisplays.relatedTags</str>
					<str>def configure(rootContainer, pds):
	import app, system
	
	print &quot;Configuring the related tags...&quot;
	
	project = system.util.getProjectName()
	ruleId = rootContainer.ruleId
	
	# The results are ordered, so if I just keep track of the last one I can keep a running index
	lastChart = &quot;&quot;
	lastAxis = &quot;&quot;

	headers = [&quot;tagPath&quot;, &quot;names&quot;]

	topLeftTags = []
	topRightTags = []
	middleLeftTags = []
	middleRightTags = []
	bottomLeftTags = []
	bottomRightTags = []

	for record in pds:
		chart = record[ &quot;Chart&quot; ]
		axis = record[ &quot;Axis&quot; ]
		name = record[ &quot;Name&quot; ]
		tagName = app.tags.get.historyTagPath(name)
		description = record[ &quot;Description&quot; ]
		print chart, axis, tagName

		if chart == lastChart and axis == LastAxis:
			idx = idx + 1
		else:
			idx = 1

		# Put the tagnames that we fetched into the tag name slots that we set aside
		if chart == &quot;TOP&quot;:
			if axis == &quot;LEFT&quot;:
				topLeftTags.append([tagName, name])
			else:
				topRightTags.append([tagName, name])

		elif chart == &quot;MIDDLE&quot;:
			if axis == &quot;LEFT&quot;:
				middleLeftTags.append([tagName, name])
			else:
				middleRightTags.append([tagName, name])

		elif chart == &quot;BOTTOM&quot;:
			if axis == &quot;LEFT&quot;:
				bottomLeftTags.append([tagName, name])
			else:
				bottomRightTags.append([tagName, name])
		
		else:
			chart = None

	# Now create a dataset for each axis

	chart = rootContainer.getComponent(&quot;Top Chart&quot;)
	ds = system.dataset.toDataSet(headers, topLeftTags)
	chart.setPropertyValue(&quot;leftTags&quot;, ds)
	ds = system.dataset.toDataSet(headers, topRightTags)
	chart.setPropertyValue(&quot;rightTags&quot;, ds)
	if len(topLeftTags) == 0 and len(topRightTags) == 0:
		chart._visible = False
	else:
		chart._visible = True

	chart = rootContainer.getComponent(&quot;Middle Chart&quot;)
	ds = system.dataset.toDataSet(headers, middleLeftTags)
	chart.setPropertyValue(&quot;leftTags&quot;, ds)
	ds = system.dataset.toDataSet(headers, middleRightTags)
	chart.setPropertyValue(&quot;rightTags&quot;, ds)
	if len(middleLeftTags) == 0 and len(middleRightTags) == 0:
		chart._visible = False
	else:
		chart._visible = True

	chart = rootContainer.getComponent(&quot;Bottom Chart&quot;)
	ds = system.dataset.toDataSet(headers, bottomLeftTags)
	chart.setPropertyValue(&quot;leftTags&quot;, ds)
	ds = system.dataset.toDataSet(headers, bottomRightTags)
	chart.setPropertyValue(&quot;rightTags&quot;, ds)
	if len(bottomLeftTags) == 0 and len(bottomRightTags) == 0:
		chart._visible = False
	else:
		chart._visible = True


def clear(rootContainer):
	import system
	print &quot;Clearing out the related tags structure&quot;
	
	headers = [&quot;tagPath&quot;, &quot;tagLegend&quot;]
	data = []
	ds = system.dataset.toDataSet(headers, data)
	pdsEmpty = system.dataset.toPyDataSet(ds)
	
	for chartName in [&quot;Top Chart&quot;, &quot;Middle Chart&quot;, &quot;Bottom Chart&quot;]:
		chart = rootContainer.getComponent(chartName)
		for axis in [&quot;left&quot;, &quot;right&quot;]:
			for idx in range(1, 4):
				chart.setPropertyValue(axis + &quot;Tag&quot; + str(idx), None)

		chart.setPropertyValue(&quot;leftTags&quot;, pdsEmpty)		
		chart.setPropertyValue(&quot;rightTags&quot;, pdsEmpty)


def fetch(ruleId):
	import system
	
	SQL = &quot;select Name, Chart, Axis, Description from RelatedTagView where ModelId = ? &quot;
	SQL = SQL + &quot; order by chart, axis&quot;

	pds = system.db.runPrepQuery(SQL, args = [ ruleId ])
	
	return pds


def updateAllCharts(rootContainer):
	import app, system
	print &quot;Updating all charts.&quot;
	
	dateWidget = rootContainer.getComponent(&quot;Date Range&quot;)
	startDate = dateWidget.startDate
	endDate = dateWidget.endDate

	for chartName in [ &quot;Top Chart&quot;, &quot;Middle Chart&quot;, &quot;Bottom Chart&quot; ]:
		print &quot;Updating &quot;, chartName
		template = rootContainer.getComponent(chartName)
	
		# Prepare an empty dataset to stuff into the chart in the event that there are no tags
		headers = [&quot;age&quot;, &quot;val&quot;]
		data = []
		dsEmpty = system.dataset.toDataSet(headers, data)
		pdsEmpty = system.dataset.toPyDataSet(dsEmpty)

		# Handle the left axis	
		ds = template.leftTags
		if ds.rowCount == 0:
			ds = dsEmpty
		else:
			print &quot;There are LEFT tags&quot;
			pds = system.dataset.toPyDataSet(ds)
			tagPaths = []

			# The documentation is not right here.  There is going to be one extra column in the ds than there are 
			# tags because the first column is timestamp.
			names = [&quot;tstamp&quot;] 
			for row in pds:
				tagPaths.append(row[&quot;tagPath&quot;])
				names.append(row[&quot;names&quot;])

			print &quot;Querying left tags: &quot;, tagPaths
			ds = system.tag.queryTagHistory(paths = tagPaths, startDate = startDate, endDate = endDate, columnNames = names)

		template.leftData = ds
	
		# Handle the RIGHT axis	
		ds = template.rightTags
		if ds.rowCount == 0:
			ds = dsEmpty
		else:
			print &quot;There are RIGHT tags&quot;
			pds = system.dataset.toPyDataSet(ds)
			tagPaths = []

			# The documentation is not right here.  There is going to be one extra column in the ds than there are 
			# tags because the first column is timestamp.
			names = [&quot;tstamp&quot;] 
			for row in pds:
				tagPaths.append(row[&quot;tagPath&quot;])
				names.append(row[&quot;names&quot;])

			print &quot;Querying right tags: &quot;, tagPaths
			ds = system.tag.queryTagHistory(paths = tagPaths, startDate = startDate, endDate = endDate, columnNames = names)

		template.rightData = ds</str>
				</o-c>
				<o-c m="put" s="2;O;O">
					<str>diagnostics.alerts.historicBrowser</str>
					<str>def reset(rootContainer):
	import app, system
	print &quot;In reset...&quot;
	
	rootContainer.getComponent(&quot;Name Field&quot;).text = &quot;&quot;
	rootContainer.getComponent(&quot;Id Field&quot;).text = &quot;&quot;


def update(rootContainer):
	import app, system
	print &quot;In update...&quot;
		
	username = system.tag.read(&apos;[System]Client/User/Username&apos;).value

	nameFilter = rootContainer.getComponent(&apos;Name Field&apos;).text
	if nameFilter == &apos;&apos;:
		nameFilter = &apos;%&apos;
		
	idFilter = rootContainer.getComponent(&apos;Id Field&apos;).text
	if idFilter == &apos;&apos;:
		idFilter = &apos;%&apos;
	
	dateRange = rootContainer.getComponent(&apos;Date Range&apos;)
	
	print &quot;Username: %s&quot; % (username)
	print &quot;Name filter: %s&quot; % (nameFilter)
	print &quot;Id filter: %s&quot; % (idFilter)
	print &quot;Date: %s to %s&quot; % (dateRange.startDate, dateRange.endDate)

	SQL = &quot;SELECT EL.EventLogID, EL.EventTimeStamp, RMT.Name AS Type, RM.Name, RM.Explanation, &apos;&lt;HTML&gt;&apos; + RM.Name + &apos;:&apos; + RM.Explanation, \
		EL.RuleID AS ID, EL.Status, EL.AcknowledgedBy, EL.AckTimeStamp, EL.Ranking \
	FROM EventLog EL INNER JOIN \
		RuleModel RM ON EL.RuleID = RM.RuleModelID INNER JOIN \
		RuleModelType RMT ON RM.TypeID = RMT.ruleModelTypeID INNER JOIN \
		RuleDestination RD ON EL.RuleID = RD.RuleID INNER JOIN \
		UserCurrentSubscription UCS ON RD.DestinationID = UCS.DestinationID INNER JOIN \
		Users U ON UCS.UserID = U.UserID \
	where EL.Status = &apos;True&apos; \
		and U.UserName = ? \
		and RM.name like ? \
		and RM.RuleModelId like ? \
		and EL.eventTimeStamp &gt; ? \
		and EL.eventTimeStamp &lt; ? \
	GROUP BY EL.EventLogID, EL.EventTimeStamp, RM.Name, RM.Explanation, RMT.Name, EL.RuleID, \
	                      EL.Status, EL.AcknowledgedBy, EL.AckTimeStamp, EL.Ranking, U.UserName	\
	ORDER BY EL.EventLogID DESC&quot;
		
	print SQL
	
	pds = system.db.runPrepQuery(SQL, args = [username, nameFilter, idFilter, dateRange.startDate, dateRange.endDate])

	print pds
	table = rootContainer.getComponent(&quot;Table&quot;)
	table.data = pds</str>
				</o-c>
			</o>
		</o-c>
	</o>
</objects>
